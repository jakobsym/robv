{"version":3,"sources":["../../ws-impl/src/index.browser.ts","../src/websocket-connection.ts","../src/websocket-transport.ts"],"names":["index_browser_default","resolve","reject","e"],"mappings":"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","file":"index.native.mjs","sourcesContent":["export default globalThis.WebSocket;\n","import {\n    SOLANA_ERROR__INVARIANT_VIOLATION__WEBSOCKET_MESSAGE_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE,\n    SOLANA_ERROR__INVARIANT_VIOLATION__WEBSOCKET_MESSAGE_ITERATOR_STATE_MISSING,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_CLOSED_BEFORE_MESSAGE_BUFFERED,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_CONNECTION_CLOSED,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_FAILED_TO_CONNECT,\n    SolanaError,\n} from '@solana/errors';\nimport WebSocket from '@solana/ws-impl';\n\ntype Config = Readonly<{\n    sendBufferHighWatermark: number;\n    signal: AbortSignal;\n    url: string;\n}>;\ntype IteratorKey = symbol;\ntype IteratorState =\n    | {\n          __hasPolled: false;\n          queuedMessages: unknown[];\n      }\n    | {\n          __hasPolled: true;\n          onError: Parameters<ConstructorParameters<typeof Promise>[0]>[1];\n          onMessage: Parameters<ConstructorParameters<typeof Promise>[0]>[0];\n      };\nexport type RpcWebSocketConnection = Readonly<{\n    send(payload: unknown): Promise<void>;\n    [Symbol.asyncIterator](): AsyncGenerator<unknown>;\n}>;\n\nlet EXPLICIT_ABORT_TOKEN: symbol;\nfunction createExplicitAbortToken() {\n    // This function is an annoying workaround to prevent `process.env.NODE_ENV` from appearing at\n    // the top level of this module and thwarting an optimizing compiler's attempt to tree-shake.\n    return Symbol(\n        process.env.NODE_ENV !== \"production\"\n            ? \"This symbol is thrown from a socket's iterator when the connection is explicitly aborted by the user\"\n            : undefined,\n    );\n}\n\nexport async function createWebSocketConnection({\n    sendBufferHighWatermark,\n    signal,\n    url,\n}: Config): Promise<RpcWebSocketConnection> {\n    return await new Promise((resolve, reject) => {\n        signal.addEventListener('abort', handleAbort, { once: true });\n        const iteratorState: Map<IteratorKey, IteratorState> = new Map();\n        function errorAndClearAllIteratorStates(reason: unknown) {\n            const errorCallbacks = [...iteratorState.values()]\n                .filter((state): state is Extract<IteratorState, { __hasPolled: true }> => state.__hasPolled)\n                .map(({ onError }) => onError);\n            iteratorState.clear();\n            errorCallbacks.forEach(cb => {\n                try {\n                    cb(reason);\n                } catch {\n                    /* empty */\n                }\n            });\n        }\n        function handleAbort() {\n            errorAndClearAllIteratorStates((EXPLICIT_ABORT_TOKEN ||= createExplicitAbortToken()));\n            if (webSocket.readyState !== WebSocket.CLOSED && webSocket.readyState !== WebSocket.CLOSING) {\n                webSocket.close(1000);\n            }\n        }\n        function handleClose(ev: CloseEvent) {\n            bufferDrainWatcher?.onCancel();\n            signal.removeEventListener('abort', handleAbort);\n            webSocket.removeEventListener('close', handleClose);\n            webSocket.removeEventListener('error', handleError);\n            webSocket.removeEventListener('open', handleOpen);\n            webSocket.removeEventListener('message', handleMessage);\n            errorAndClearAllIteratorStates(ev);\n        }\n        function handleError(ev: Event) {\n            if (!hasConnected) {\n                reject(\n                    new SolanaError(SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_FAILED_TO_CONNECT, {\n                        errorEvent: ev,\n                    }),\n                );\n            }\n        }\n        let hasConnected = false;\n        let bufferDrainWatcher: Readonly<{ onCancel(): void; promise: Promise<void> }> | undefined;\n        function handleOpen() {\n            hasConnected = true;\n            resolve({\n                async send(payload: unknown) {\n                    const message = JSON.stringify(payload);\n                    if (\n                        !bufferDrainWatcher &&\n                        webSocket.readyState === WebSocket.OPEN &&\n                        webSocket.bufferedAmount > sendBufferHighWatermark\n                    ) {\n                        let onCancel: () => void;\n                        const promise = new Promise<void>((resolve, reject) => {\n                            const intervalId = setInterval(() => {\n                                if (\n                                    webSocket.readyState !== WebSocket.OPEN ||\n                                    !(webSocket.bufferedAmount > sendBufferHighWatermark)\n                                ) {\n                                    clearInterval(intervalId);\n                                    bufferDrainWatcher = undefined;\n                                    resolve();\n                                }\n                            }, 16);\n                            onCancel = () => {\n                                bufferDrainWatcher = undefined;\n                                clearInterval(intervalId);\n                                reject(\n                                    new SolanaError(\n                                        SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_CLOSED_BEFORE_MESSAGE_BUFFERED,\n                                    ),\n                                );\n                            };\n                        });\n                        bufferDrainWatcher = {\n                            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                            // @ts-ignore\n                            onCancel,\n                            promise,\n                        };\n                    }\n                    if (bufferDrainWatcher) {\n                        await bufferDrainWatcher.promise;\n                    }\n                    webSocket.send(message);\n                },\n                async *[Symbol.asyncIterator]() {\n                    const iteratorKey = Symbol();\n                    iteratorState.set(iteratorKey, { __hasPolled: false, queuedMessages: [] });\n                    try {\n                        while (true) {\n                            const state = iteratorState.get(iteratorKey);\n                            if (!state) {\n                                // There should always be state by now.\n                                throw new SolanaError(\n                                    SOLANA_ERROR__INVARIANT_VIOLATION__WEBSOCKET_MESSAGE_ITERATOR_STATE_MISSING,\n                                );\n                            }\n                            if (state.__hasPolled) {\n                                // You should never be able to poll twice in a row.\n                                throw new SolanaError(\n                                    SOLANA_ERROR__INVARIANT_VIOLATION__WEBSOCKET_MESSAGE_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE,\n                                );\n                            }\n                            const queuedMessages = state.queuedMessages;\n                            if (queuedMessages.length) {\n                                state.queuedMessages = [];\n                                yield* queuedMessages;\n                            } else {\n                                try {\n                                    yield await new Promise((resolve, reject) => {\n                                        iteratorState.set(iteratorKey, {\n                                            __hasPolled: true,\n                                            onError: reject,\n                                            onMessage: resolve,\n                                        });\n                                    });\n                                } catch (e) {\n                                    if (e === (EXPLICIT_ABORT_TOKEN ||= createExplicitAbortToken())) {\n                                        return;\n                                    } else {\n                                        throw new SolanaError(\n                                            SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_CONNECTION_CLOSED,\n                                            {\n                                                cause: e,\n                                            },\n                                        );\n                                    }\n                                }\n                            }\n                        }\n                    } finally {\n                        iteratorState.delete(iteratorKey);\n                    }\n                },\n            });\n        }\n        function handleMessage({ data }: MessageEvent) {\n            const message = JSON.parse(data);\n            iteratorState.forEach((state, iteratorKey) => {\n                if (state.__hasPolled) {\n                    const { onMessage } = state;\n                    iteratorState.set(iteratorKey, { __hasPolled: false, queuedMessages: [] });\n                    onMessage(message);\n                } else {\n                    state.queuedMessages.push(message);\n                }\n            });\n        }\n        const webSocket = new WebSocket(url);\n        webSocket.addEventListener('close', handleClose);\n        webSocket.addEventListener('error', handleError);\n        webSocket.addEventListener('open', handleOpen);\n        webSocket.addEventListener('message', handleMessage);\n    });\n}\n","import { RpcSubscriptionsTransport } from '@solana/rpc-subscriptions-spec';\n\nimport { createWebSocketConnection } from './websocket-connection';\n\ntype Config = Readonly<{\n    sendBufferHighWatermark: number;\n    url: string;\n}>;\n\nexport function createWebSocketTransport({ sendBufferHighWatermark, url }: Config): RpcSubscriptionsTransport {\n    if (/^wss?:/i.test(url) === false) {\n        const protocolMatch = url.match(/^([^:]+):/);\n        throw new DOMException(\n            protocolMatch\n                ? `Failed to construct 'WebSocket': The URL's scheme must be either 'ws' or 'wss'. '${protocolMatch[1]}:' is not allowed.`\n                : `Failed to construct 'WebSocket': The URL '${url}' is invalid.`,\n        );\n    }\n    return async function sendWebSocketMessage({ payload, signal }: Parameters<RpcSubscriptionsTransport>[0]) {\n        signal?.throwIfAborted();\n        const connection = await createWebSocketConnection({\n            sendBufferHighWatermark,\n            signal,\n            url,\n        });\n        signal?.throwIfAborted();\n        await connection.send(payload);\n        return {\n            [Symbol.asyncIterator]: connection[Symbol.asyncIterator].bind(connection),\n            send_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: connection.send.bind(connection),\n        };\n    };\n}\n"]}