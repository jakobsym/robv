{"version":3,"sources":["../src/http-transport-headers.ts","../src/http-transport.ts"],"names":["SolanaError","SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN","SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR"],"mappings":"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","file":"index.node.cjs","sourcesContent":["import { SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN, SolanaError } from '@solana/errors';\n\nexport type AllowedHttpRequestHeaders = Readonly<\n    {\n        // Someone can still sneak a forbidden header past Typescript if they do something like\n        // fOo-BaR, but at that point they deserve the runtime failure.\n        [K in DisallowedHeaders | ForbiddenHeaders as\n            | Capitalize<Lowercase<K>> // `Foo-bar`\n            | K // `Foo-Bar`\n            | Lowercase<K> // `foo-bar`\n            | Uncapitalize<K> // `foo-Bar`\n            // `FOO-BAR`\n            | Uppercase<K>]?: never;\n    } & { [headerName: string]: string }\n>;\n// These are headers that we simply don't allow the developer to override because they're\n// fundamental to the operation of the JSON-RPC transport.\ntype DisallowedHeaders = 'Accept' | 'Content-Length' | 'Content-Type' | 'Solana-Client';\ntype ForbiddenHeaders =\n    | 'Accept-Charset'\n    | 'Accept-Encoding'\n    | 'Access-Control-Request-Headers'\n    | 'Access-Control-Request-Method'\n    | 'Connection'\n    | 'Content-Length'\n    | 'Cookie'\n    | 'Date'\n    | 'DNT'\n    | 'Expect'\n    | 'Host'\n    | 'Keep-Alive'\n    | 'Origin'\n    | 'Permissions-Policy'\n    | 'Referer'\n    | 'TE'\n    | 'Trailer'\n    | 'Transfer-Encoding'\n    | 'Upgrade'\n    | 'Via'\n    | `Proxy-${string}`\n    | `Sec-${string}`;\n\n// These are headers which are fundamental to the JSON-RPC transport, and must not be modified.\nconst DISALLOWED_HEADERS: Record<string, boolean> = {\n    accept: true,\n    'content-length': true,\n    'content-type': true,\n};\n// https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name\nconst FORBIDDEN_HEADERS: Record<string, boolean> = {\n    'accept-charset': true,\n    'accept-encoding': true,\n    'access-control-request-headers': true,\n    'access-control-request-method': true,\n    connection: true,\n    'content-length': true,\n    cookie: true,\n    date: true,\n    dnt: true,\n    expect: true,\n    host: true,\n    'keep-alive': true,\n    origin: true,\n    'permissions-policy': true,\n    // Prefix matching is implemented in code, below.\n    // 'proxy-': true,\n    // 'sec-': true,\n    referer: true,\n    te: true,\n    trailer: true,\n    'transfer-encoding': true,\n    upgrade: true,\n    via: true,\n};\n\nexport function assertIsAllowedHttpRequestHeaders(\n    headers: Record<string, string>,\n): asserts headers is AllowedHttpRequestHeaders {\n    const badHeaders = Object.keys(headers).filter(headerName => {\n        const lowercaseHeaderName = headerName.toLowerCase();\n        return (\n            DISALLOWED_HEADERS[headerName.toLowerCase()] === true ||\n            FORBIDDEN_HEADERS[headerName.toLowerCase()] === true ||\n            lowercaseHeaderName.startsWith('proxy-') ||\n            lowercaseHeaderName.startsWith('sec-')\n        );\n    });\n    if (badHeaders.length > 0) {\n        throw new SolanaError(SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN, {\n            headers: badHeaders,\n        });\n    }\n}\n\n/**\n * Lowercasing header names makes it easier to override user-supplied headers, such as those defined\n * in the `DisallowedHeaders` type.\n */\nexport function normalizeHeaders<T extends Record<string, string>>(\n    headers: T,\n): { [K in string & keyof T as Lowercase<K>]: T[K] } {\n    const out: Record<string, string> = {};\n    for (const headerName in headers) {\n        out[headerName.toLowerCase()] = headers[headerName];\n    }\n    return out as { [K in string & keyof T as Lowercase<K>]: T[K] };\n}\n","import { SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR, SolanaError } from '@solana/errors';\nimport { RpcTransport } from '@solana/rpc-spec';\nimport type Dispatcher from 'undici-types/dispatcher';\n\nimport {\n    AllowedHttpRequestHeaders,\n    assertIsAllowedHttpRequestHeaders,\n    normalizeHeaders,\n} from './http-transport-headers';\n\ntype Config = Readonly<{\n    dispatcher_NODE_ONLY?: Dispatcher;\n    headers?: AllowedHttpRequestHeaders;\n    url: string;\n}>;\n\nlet didWarnDispatcherWasSuppliedInNonNodeEnvironment = false;\nfunction warnDispatcherWasSuppliedInNonNodeEnvironment() {\n    if (didWarnDispatcherWasSuppliedInNonNodeEnvironment) {\n        return;\n    }\n    didWarnDispatcherWasSuppliedInNonNodeEnvironment = true;\n    console.warn(\n        'You have supplied a `Dispatcher` to `createHttpTransport()`. It has been ignored ' +\n            'because Undici dispatchers only work in Node environments. To eliminate this ' +\n            'warning, omit the `dispatcher_NODE_ONLY` property from your config when running in ' +\n            'a non-Node environment.',\n    );\n}\n\nexport function createHttpTransport(config: Config): RpcTransport {\n    if (process.env.NODE_ENV !== \"production\" && !__NODEJS__ && 'dispatcher_NODE_ONLY' in config) {\n        warnDispatcherWasSuppliedInNonNodeEnvironment();\n    }\n    const { headers, url } = config;\n    if (process.env.NODE_ENV !== \"production\" && headers) {\n        assertIsAllowedHttpRequestHeaders(headers);\n    }\n    let dispatcherConfig: { dispatcher: Dispatcher | undefined } | undefined;\n    if (__NODEJS__ && 'dispatcher_NODE_ONLY' in config) {\n        dispatcherConfig = { dispatcher: config.dispatcher_NODE_ONLY };\n    }\n    const customHeaders = headers && normalizeHeaders(headers);\n    return async function makeHttpRequest<TResponse>({\n        payload,\n        signal,\n    }: Parameters<RpcTransport>[0]): Promise<TResponse> {\n        const body = JSON.stringify(payload);\n        const requestInfo = {\n            ...dispatcherConfig,\n            body,\n            headers: {\n                ...customHeaders,\n                // Keep these headers lowercase so they will override any user-supplied headers above.\n                accept: 'application/json',\n                'content-length': body.length.toString(),\n                'content-type': 'application/json; charset=utf-8',\n            },\n            method: 'POST',\n            signal,\n        };\n        const response = await fetch(url, requestInfo);\n        if (!response.ok) {\n            throw new SolanaError(SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR, {\n                message: response.statusText,\n                statusCode: response.status,\n            });\n        }\n        return (await response.json()) as TResponse;\n    };\n}\n"]}