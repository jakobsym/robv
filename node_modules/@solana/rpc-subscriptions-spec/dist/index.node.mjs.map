{"version":3,"sources":["../src/rpc-subscriptions.ts","../src/rpc-subscriptions-api.ts"],"names":[],"mappings":"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","file":"index.node.mjs","sourcesContent":["import {\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_REQUEST,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID,\n    SolanaError,\n} from '@solana/errors';\nimport { getSolanaErrorFromJsonRpcError } from '@solana/errors';\nimport {\n    Callable,\n    createRpcMessage,\n    Flatten,\n    OverloadImplementations,\n    RpcResponse,\n    UnionToIntersection,\n} from '@solana/rpc-spec-types';\n\nimport { RpcSubscriptionsApi } from './rpc-subscriptions-api';\nimport {\n    PendingRpcSubscriptionsRequest,\n    RpcSubscribeOptions,\n    RpcSubscriptionsRequest,\n} from './rpc-subscriptions-request';\nimport { RpcSubscriptionsTransport } from './rpc-subscriptions-transport';\n\nexport type RpcSubscriptionsConfig<\n    TRpcMethods,\n    TRpcSubscriptionsTransport extends RpcSubscriptionsTransport,\n> = Readonly<{\n    api: RpcSubscriptionsApi<TRpcMethods>;\n    transport: TRpcSubscriptionsTransport;\n}>;\n\nexport type RpcSubscriptions<TRpcSubscriptionsMethods> = {\n    [TMethodName in keyof TRpcSubscriptionsMethods]: PendingRpcSubscriptionsRequestBuilder<\n        OverloadImplementations<TRpcSubscriptionsMethods, TMethodName>\n    >;\n};\n\ntype PendingRpcSubscriptionsRequestBuilder<TSubscriptionMethodImplementations> = UnionToIntersection<\n    Flatten<{\n        [P in keyof TSubscriptionMethodImplementations]: PendingRpcSubscriptionsRequestReturnTypeMapper<\n            TSubscriptionMethodImplementations[P]\n        >;\n    }>\n>;\n\ntype PendingRpcSubscriptionsRequestReturnTypeMapper<TSubscriptionMethodImplementation> =\n    // Check that this property of the TRpcSubscriptionMethods interface is, in fact, a function.\n    TSubscriptionMethodImplementation extends Callable\n        ? (\n              ...args: Parameters<TSubscriptionMethodImplementation>\n          ) => PendingRpcSubscriptionsRequest<ReturnType<TSubscriptionMethodImplementation>>\n        : never;\n\ntype RpcNotification<TNotification> = Readonly<{\n    params: Readonly<{\n        result: TNotification;\n        subscription: number;\n    }>;\n}>;\n\ntype RpcSubscriptionId = number;\n\nexport function createSubscriptionRpc<\n    TRpcSubscriptionsApiMethods,\n    TRpcSubscriptionsTransport extends RpcSubscriptionsTransport,\n>(\n    rpcConfig: RpcSubscriptionsConfig<TRpcSubscriptionsApiMethods, TRpcSubscriptionsTransport>,\n): RpcSubscriptions<TRpcSubscriptionsApiMethods> {\n    return makeProxy(rpcConfig);\n}\n\nfunction makeProxy<TRpcSubscriptionsApiMethods, TRpcSubscriptionsTransport extends RpcSubscriptionsTransport>(\n    rpcConfig: RpcSubscriptionsConfig<TRpcSubscriptionsApiMethods, TRpcSubscriptionsTransport>,\n): RpcSubscriptions<TRpcSubscriptionsApiMethods> {\n    return new Proxy(rpcConfig.api, {\n        defineProperty() {\n            return false;\n        },\n        deleteProperty() {\n            return false;\n        },\n        get(target, p, receiver) {\n            return function (...rawParams: unknown[]) {\n                const notificationName = p.toString();\n                const createRpcSubscription = Reflect.get(target, notificationName, receiver);\n                if (p.toString().endsWith('Notifications') === false && !createRpcSubscription) {\n                    throw new SolanaError(SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_REQUEST, {\n                        notificationName,\n                    });\n                }\n                const newRequest = createRpcSubscription\n                    ? createRpcSubscription(...rawParams)\n                    : {\n                          params: rawParams,\n                          subscribeMethodName: notificationName.replace(/Notifications$/, 'Subscribe'),\n                          unsubscribeMethodName: notificationName.replace(/Notifications$/, 'Unsubscribe'),\n                      };\n                return createPendingRpcSubscription(rpcConfig, newRequest);\n            };\n        },\n    }) as RpcSubscriptions<TRpcSubscriptionsApiMethods>;\n}\n\nfunction registerIterableCleanup(iterable: AsyncIterable<unknown>, cleanupFn: CallableFunction) {\n    (async () => {\n        try {\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n            for await (const _ of iterable);\n        } catch {\n            /* empty */\n        } finally {\n            // Run the cleanup function.\n            cleanupFn();\n        }\n    })();\n}\n\nfunction createPendingRpcSubscription<\n    TRpcSubscriptionsApiMethods,\n    TRpcSubscriptionsTransport extends RpcSubscriptionsTransport,\n    TNotification,\n>(\n    rpcConfig: RpcSubscriptionsConfig<TRpcSubscriptionsApiMethods, TRpcSubscriptionsTransport>,\n    { params, subscribeMethodName, unsubscribeMethodName, responseTransformer }: RpcSubscriptionsRequest<TNotification>,\n): PendingRpcSubscriptionsRequest<TNotification> {\n    return {\n        async subscribe({ abortSignal }: RpcSubscribeOptions): Promise<AsyncIterable<TNotification>> {\n            abortSignal.throwIfAborted();\n            let subscriptionId: number | undefined;\n            function handleCleanup() {\n                if (subscriptionId !== undefined) {\n                    const payload = createRpcMessage(unsubscribeMethodName, [subscriptionId]);\n                    connection.send_DO_NOT_USE_OR_YOU_WILL_BE_FIRED(payload).finally(() => {\n                        connectionAbortController.abort();\n                    });\n                } else {\n                    connectionAbortController.abort();\n                }\n            }\n            abortSignal.addEventListener('abort', handleCleanup);\n            /**\n             * STEP 1: Send the subscribe message.\n             */\n            const connectionAbortController = new AbortController();\n            const subscribeMessage = createRpcMessage(subscribeMethodName, params);\n            const connection = await rpcConfig.transport({\n                payload: subscribeMessage,\n                signal: connectionAbortController.signal,\n            });\n            function handleConnectionCleanup() {\n                abortSignal.removeEventListener('abort', handleCleanup);\n            }\n            registerIterableCleanup(connection, handleConnectionCleanup);\n            /**\n             * STEP 2: Wait for the acknowledgement from the server with the subscription id.\n             */\n            for await (const message of connection as AsyncIterable<\n                RpcNotification<unknown> | RpcResponse<RpcSubscriptionId>\n            >) {\n                if ('id' in message && message.id === subscribeMessage.id) {\n                    if ('error' in message) {\n                        throw getSolanaErrorFromJsonRpcError(message.error);\n                    } else {\n                        subscriptionId = message.result as RpcSubscriptionId;\n                        break;\n                    }\n                }\n            }\n            if (subscriptionId == null) {\n                throw new SolanaError(SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID);\n            }\n            /**\n             * STEP 3: Return an iterable that yields notifications for this subscription id.\n             */\n            return {\n                async *[Symbol.asyncIterator]() {\n                    for await (const message of connection as AsyncIterable<\n                        RpcNotification<unknown> | RpcResponse<RpcSubscriptionId>\n                    >) {\n                        if (!('params' in message) || message.params.subscription !== subscriptionId) {\n                            continue;\n                        }\n                        const notification = message.params as TNotification;\n                        yield responseTransformer\n                            ? responseTransformer(notification, subscribeMethodName)\n                            : notification;\n                    }\n                },\n            };\n        },\n    };\n}\n","import { Callable } from '@solana/rpc-spec-types';\n\nimport { RpcSubscriptionsRequest } from './rpc-subscriptions-request';\n\nexport type RpcSubscriptionsApiConfig = Readonly<{\n    parametersTransformer?: <T extends unknown[]>(params: T, notificationName: string) => unknown[];\n    responseTransformer?: <T>(response: unknown, notificationName: string) => T;\n    subscribeNotificationNameTransformer?: (notificationName: string) => string;\n    unsubscribeNotificationNameTransformer?: (notificationName: string) => string;\n}>;\n\nexport type RpcSubscriptionsApi<TRpcSubscriptionMethods> = {\n    [MethodName in keyof TRpcSubscriptionMethods]: RpcSubscriptionsReturnTypeMapper<\n        TRpcSubscriptionMethods[MethodName]\n    >;\n};\n\ntype RpcSubscriptionsReturnTypeMapper<TRpcMethod> = TRpcMethod extends Callable\n    ? (...rawParams: unknown[]) => RpcSubscriptionsRequest<ReturnType<TRpcMethod>>\n    : never;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype RpcSubscriptionsApiMethod = (...args: any) => any;\nexport interface RpcSubscriptionsApiMethods {\n    [methodName: string]: RpcSubscriptionsApiMethod;\n}\n\nexport function createRpcSubscriptionsApi<TRpcSubscriptionsApiMethods extends RpcSubscriptionsApiMethods>(\n    config?: RpcSubscriptionsApiConfig,\n): RpcSubscriptionsApi<TRpcSubscriptionsApiMethods> {\n    return new Proxy({} as RpcSubscriptionsApi<TRpcSubscriptionsApiMethods>, {\n        defineProperty() {\n            return false;\n        },\n        deleteProperty() {\n            return false;\n        },\n        get<TNotificationName extends keyof RpcSubscriptionsApi<TRpcSubscriptionsApiMethods>>(\n            ...args: Parameters<NonNullable<ProxyHandler<RpcSubscriptionsApi<TRpcSubscriptionsApiMethods>>['get']>>\n        ) {\n            const [_, p] = args;\n            const notificationName = p.toString() as keyof TRpcSubscriptionsApiMethods as string;\n            return function (\n                ...rawParams: Parameters<\n                    TRpcSubscriptionsApiMethods[TNotificationName] extends CallableFunction\n                        ? TRpcSubscriptionsApiMethods[TNotificationName]\n                        : never\n                >\n            ): RpcSubscriptionsRequest<ReturnType<TRpcSubscriptionsApiMethods[TNotificationName]>> {\n                const params = config?.parametersTransformer\n                    ? config?.parametersTransformer(rawParams, notificationName)\n                    : rawParams;\n                const responseTransformer = config?.responseTransformer\n                    ? config?.responseTransformer<ReturnType<TRpcSubscriptionsApiMethods[TNotificationName]>>\n                    : (rawResponse: unknown) =>\n                          rawResponse as ReturnType<TRpcSubscriptionsApiMethods[TNotificationName]>;\n                const subscribeMethodName = config?.subscribeNotificationNameTransformer\n                    ? config?.subscribeNotificationNameTransformer(notificationName)\n                    : notificationName;\n                const unsubscribeMethodName = config?.unsubscribeNotificationNameTransformer\n                    ? config?.unsubscribeNotificationNameTransformer(notificationName)\n                    : notificationName;\n                return {\n                    params,\n                    responseTransformer,\n                    subscribeMethodName,\n                    unsubscribeMethodName,\n                };\n            };\n        },\n    });\n}\n"]}